;  diskcart - load disks into flashcart
;
;  Copyright (C) 2010-2011 Matthias Reichl <hias@horus.com>
;
;  This program is free software; you can redistribute it and/or modify
;  it under the terms of the GNU General Public License as published by
;  the Free Software Foundation; either version 2 of the License, or
;  (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; if not, write to the Free Software
;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

	.include "cio.inc"
	.include "libflash.inc"
	.include "cartsio.inc"
	.include "arith.inc"
	.include "iohelp.inc"

.if .def MEGA512
	.include "diskcart-mega512.inc"
.endif
.if .def MEGA4096
	.include "diskcart-mega4096.inc"
.endif
.if .def MEGAMAX8
	.include "diskcart-megamax8.inc"
.endif
.if .def FREEZER2005
	.include "diskcart-freezer05.inc"
.endif
.if .def FREEZER2011
	.include "diskcart-freezer11.inc"
.endif

; temporary ZP vectors
SRCVEC	= $E6	; ,$E7 ($E0-$E5 are used by libflash)
DSTVEC	= $E8	; ,$E9
TMPVEC	= SRCVEC	; for romram.src

START	= $2000

; address of cartridge code (8k)
CCADR	= $A000

HIADR	= CHISIO

	.BANK
	* = START

	LDA #1		; started from ROM
	.BYTE $2C	; BIT $xxxx
EXESTART
	LDA #0		; started from file

	STA RUNMODE	; remember if started from ROM or file

	LDA #$FF
	STA RAMMODE

	JSR INIT
	JSR FINIT
	JSR FDISABLE
	JSR MOVDATA

MAINLP	BPUT0 TTITLE
	JSR CODSAV	; move code to safe address

	JSR FINIT
	JSR FPRESENT
	BEQ MAINLP1
	BPUT0 TNOCAR
	JSR GETCHAR
	CPY #128
	BNE MAINLP0
	JMP EXIT

MAINLP0	JSR CODPUT	; move code back to final address
	JMP MAINLP

MAINLP1	JSR FENABLE
	JSR DETECT
	JSR FDISABLE
	LDA FTYPE
	BPL FOK

.if .def MEGAMAX8
	BPUT0 TASKRM
	JSR YESNO
	BMI MXIT
	BNE MAINLP
	LDA #0
	STA RAMMODE
	JMP MAINLP
.endif

FERR	JSR GETCHAR
	CPY #128
	BNE MAINLP0
MXIT	JMP EXIT

FOK	JSR CODPUT
	JSR FENABLE
	JSR CHKSIG
	BEQ MOK

	BPUT0 TNOINI
	JSR YESNO
	BMI MXIT
	BEQ MINIT
	JMP MAINLP

MINIT	JMP DOINIT

MOK	JSR PVERS	; print software version
	JSR PHISIO	; print highspeed SIO status

	JSR GETDTAB	; read drive table and init DISKIDX, DISKOFS
	JSR PIMG	; print loaded images
	JSR PFREE	; print free image space
	
	BPUT0 TMENU
MENULP	JSR GETCHAR
	CPY #128
	BNE MENUL1
	JMP MAINLP
MENUL1	CMP #'0
	BNE NEXIT
EXIT	JSR CLEANUP
	JMP ($A)

NEXIT	CMP #'1
	BNE NO1

	JSR PUTCHAR
	LDA #155
	JSR PUTCHAR

	BPUT0 TASKIN
	JSR YESNO
	BEQ DOINI0
	JMP MAINLP
DOINI0	JMP DOINIT

NO1	CMP #'2
	BNE NO2
	JSR PUTCHAR

	JMP ADDDISK

NO2	CMP #'3
	BNE NO3
	JSR PUTCHAR

	JMP WRDISK

NO3	CMP #'4
	BNE NO4

	LDX #$59
	LDY #$E4
	CPY SIOVEC+2
	BNE HIOFF
	LDA #0
	STA $301
	JSR HIADR	; clear highspeed SIO table
	LDX #<HIADR
	LDY #>HIADR
HIOFF	STX SIOVEC+1
	STY SIOVEC+2
	JMP MAINLP

NO4	CMP #'5
	BNE NO5
	JSR PUTCHAR
	BPUT0 TASKSC
	JSR YESNO
	BEQ DOSC1
	JMP MENULP

DOSC1	INC $42
	CARTBASE
	JMP $E477

NO5	JMP MENULP

; check for signature
CHKSIG	LDA #<OFSSIGL
	STA FLASHADR
	LDA #>OFSSIGL
	STA FLASHADR+1
	LDA #OFSSIGH
	STA FLASHADR+2
	LDA #<TSIG
	STA DATAADR
	LDA #>TSIG
	STA DATAADR+1
	JSR FENABLE
	LDY #0
	LDX #8
	JSR FCBYTE
	PHP
	JSR FDISABLE
	PLP
	RTS

; setup data/flash address for accessing drive table
SETTABA	LDA #<OFSTABL
	STA FLASHADR
	LDA #>OFSTABL
	STA FLASHADR+1
	LDA #OFSTABH
	STA FLASHADR+2
	LDA #<TABBUF
	STA DATAADR
	LDA #>TABBUF
	STA DATAADR+1
	RTS

; get drive table from flash
GETDTAB	JSR SETTABA
	JSR FENABLE
	LDY #0
	LDX #$40
	JSR FRBYTE
	JSR FDISABLE

; init disk image starting address
	LDA #<OFSIMSL
	STA DISKOFS
	LDA #>OFSIMSL
	STA DISKOFS+1
	LDA #<OFSIMSH
	STA DISKOFS+2
	LDA #>OFSIMSH
	STA DISKOFS+3

	LDA #0
	STA DISKIDX
GETDTLP	LDX DISKIDX
	LDA TABBUF+CTODENS,X	; entry is free - end of list
	BMI GETDTX
	PHA			; save density
	LDA TABBUF+CTOSECH,X	; sectors per image high
	TAY
	LDA TABBUF+CTOSECL,X	; sectors per image lo
	TAX
	PLA
	JSR CALCSIZ		; calculate size of image
	MADD32 DISKOFS, DISKOFS, DISKSIZ ; add to offset
	CLC
	LDA DISKIDX
	ADC #CTESIZE
	STA DISKIDX
	CMP #CTTSIZE
	BNE GETDTLP
GETDTX	MSUB32 IMGFREE, IMGEND, DISKOFS	; calculate free space
	RTS

; print free space
PFREE	LDX #0
PFREE0	LDA IMGFREE+1,X
	STA TMP32,X
	INX
	CPX #3
	BNE PFREE0

; divide pages by 4 to get space in kb
	LSR TMP32+2
	ROR TMP32+1
	ROR TMP32
	LSR TMP32+2
	ROR TMP32+1
	ROR TMP32

	LDX TMP32
	LDY TMP32+1
	JSR PRDEC

	BPUT0 TFREE

.if 0
; print offset
	LDA #32
	JSR PUTCHAR

	LDX #3
POFS0	STX TMPIDX
	LDA DISKOFS,X
	JSR PUTHEX
	LDX TMPIDX
	DEX
	BPL POFS0

	LDA #155
	JSR PUTCHAR
.endif
	RTS

; print software version
PVERS	BPUT0 TVERS
	LDA #<[OFSSIGL+8]
	STA FLASHADR
	LDA #>[OFSSIGL+8]
	STA FLASHADR+1
	LDA #OFSSIGH
	STA FLASHADR+2
	LDA #<SECBUF
	STA DATAADR
	LDA #>SECBUF
	STA DATAADR+1
	JSR FENABLE
	LDY #0
	LDX #8
	JSR FRBYTE
	JSR FDISABLE
	LDX #0
PVERLP	STX TMPVEC
	LDA SECBUF,X
	ORA #$80
	JSR PUTCHAR
	LDX TMPVEC
	INX
	CPX #8
	BNE PVERLP
	LDA #$19
	JMP PUTCHAR

; print image infos
PIMG	LDA #155
	JSR PUTCHAR
	LDA DISKIDX
	BNE PIMG1
PIMG0	RTS		; no images - return

PIMG1	BPUT0 TIMG
	LDA #0
	STA TMPIDX
PIMGLP	LDX TMPIDX
	LDA TABBUF+CTODENS,X
	BMI PIMG0	; end of table
	PHA		; save density
	TXA		; calculate slot number
	LSR
	LSR
	LSR
	CLC
	ADC #'1
	PHA
	LDA #'D		; output "Dx: "
	JSR PUTCHAR
	PLA
	JSR PUTCHAR
	LDA #':
	JSR PUTCHAR
	LDA #32
	JSR PUTCHAR
	LDX TMPIDX
	LDA TABBUF+CTOSECH,X	; get number of sectors
	TAY
	LDA TABBUF+CTOSECL,X
	TAX
	JSR TODEC		; convert to decimal
	JSR DEC0SP		; convert leading zeroes into spaces
	BPUT0A DECBUF+1,4	; output number of sectors
	LDA #32
	JSR PUTCHAR
	LDY #'S
	PLA			; density
	BEQ PIMG2
	LDY #'D
PIMG2	TYA
	JSR PUTCHAR
	LDA #'D
	JSR PUTCHAR
	LDA #32
	JSR PUTCHAR
	
	LDX TMPIDX
	LDA TABBUF+CTOACTI,X
	BEQ PIMG3		; image active, output name

	BPUT0 TINACT
	JMP PIMG4

PIMG3
; fetch image name from cart
	LDA #COFNAME
	STA FLASHADR
	LDA TABBUF+CTOSPL,X
	STA FLASHADR+1
	LDA TABBUF+CTOSPH,X
	STA FLASHADR+2
	LDA #<NAMBUF
	STA DATAADR
	LDA #>NAMBUF
	STA DATAADR+1
	JSR FENABLE
	LDY #0
	LDX #CLNNAME
	JSR FRBYTE
	JSR FDISABLE
	LDA #155
	STA NAMBUF+CLNNAME-1	; add terminating EOL, just in case
	PRINT0 NAMBUF

PIMG4	CLC
	LDA TMPIDX
	ADC #8
	STA TMPIDX
	CMP #$40
	BEQ PIMGX
	JMP PIMGLP
PIMGX	RTS

; print highspeed SIO status
PHISIO	BPUT0 THISIO
	LDA SIOVEC+2
	CMP #>HIADR
	BEQ PHISIO1
	LDA #['f]+$80
	JSR PUTCHAR
	LDA #['f]+$80
	JSR PUTCHAR
	JMP PHISIO2
PHISIO1	LDA #['n]+$80
	JSR PUTCHAR
PHISIO2	LDA #$19
	JSR PUTCHAR
	LDA #155
	JMP PUTCHAR

DOINIT	
	BPUT0 TASKAU
	LDA #0
	STA AUTOFLG
	JSR YESNO
	BPL DOINI1
	JMP MAINLP
DOINI1	BNE DOINI2
	INC AUTOFLG

DOINI2	BPUT0 TINIT

	LDA RAMMODE
	BEQ DOINIT1

	BPUT0 TERAS
	JSR ERASE
	BPL DOINIT1
DOINIE1	JSR PERROR
	JMP DOCONT
DOINIT1	

	JSR PPROGF

; copy cartridge code to data buffer
	LDA #<CCADR
	STA SRCVEC
	LDA #>CCADR
	STA SRCVEC+1
	LDA #<DATABUF
	STA DSTVEC
	LDA #>DATABUF
	STA DSTVEC+1
	LDX #$20	; $20 pages = 8k
	JSR COPYPAG

; clear drive table
	LDA #$FF
	LDY #$3F
CLRDT	STA DATABUF+[CARTTAB-CARTSTRT],Y
	DEY
	BPL CLRDT

; set autostart flag
	LDA AUTOFLG
	STA DATABUF+[CAUTOF-CARTSTRT]

; setup addresses
	LDA #<OFSCODL
	STA FLASHADR
	LDA #>OFSCODL
	STA FLASHADR+1
	LDA #OFSCODH
	STA FLASHADR+2
	LDA #<DATABUF
	STA DATAADR
	LDA #>DATABUF
	STA DATAADR+1
	JSR FENABLE
	LDX #$20
	JSR FWPAGE
	PHP
	JSR FDISABLE
	PLP
	BPL DOINIT2
DOINIE2	JSR PERRADR
	JMP DOCONT
DOINIT2	

; copy diskwriter program code
	LDA #<START
	STA SRCVEC
	LDA #>START
	STA SRCVEC+1
	LDA #<DATABUF
	STA DSTVEC
	LDA #>DATABUF
	STA DSTVEC+1
	LDX #>(DCODEL+255)
	JSR COPYPAG

; clear unused part of last page
	LDY #<DCODEL
	BEQ NOCLRDC
	LDA #$FF
CLRDC	STA DATABUF+(DCODEL&$ff00),Y
	INY
	BNE CLRDC
NOCLRDC

; and flash it
	LDA #<OFSDWL
	STA FLASHADR
	LDA #>OFSDWL
	STA FLASHADR+1
	LDA #OFSDWH
	STA FLASHADR+2

	JSR FENABLE
	LDX #>(DCODEL+255)
	JSR FWPAGE
	PHP
	JSR FDISABLE
	PLP
	BMI DOINIE2


.if .def MEGAMAX8
; also program cartdrige startup code into last bank
	LDY #0
STCLP	LDA CCADR+$1FE0,Y
	STA DATABUF,Y
	INY
	CPY #$20
	BNE STCLP

	LDA #<[OFSIMEL+$1FE0]
	STA FLASHADR
	LDA #>[OFSIMEL+$1FE0]
	STA FLASHADR+1
	LDA #OFSIMEH
	STA FLASHADR+2

	JSR FENABLE
	LDY #0
	LDX #$20
	JSR FWBYTE
	PHP
	JSR FDISABLE
	PLP
	BPL DOINIAOK
	JMP DOINIE2
DOINIAOK
.endif

	JSR POK

DOCONTS	BPUT0 TFINI

DOCONT	BPUT0 TCONT
	JSR GETCHAR
	JMP MAINLP


; input drive number

GETDRVN	BPUT0 TDRVNO
GETDR1	JSR GETCHAR
	CPY #128
	BNE GETDR2
	PLA
	PLA
	JMP DOCONT
GETDR2	CMP #'1
	BCC GETDR1
	CMP #'9
	BCS GETDR1
	PHA
	JSR PUTCHAR
	LDA #155
	JSR PUTCHAR
	PLA
	SEC
	SBC #'0
	STA $301
	RTS

; X=0: write disk to flash
; X=1: write flash to disk

DOIO	STX IODIR

	LDA #0		; start at sector 0
	STA $30A
	STA $30B

; total number of sectors (including sector 0)
	CLC
	LDA DISKSEC
	ADC #1
	STA DISKREM
	LDA DISKSEC+1
	ADC #0
	STA DISKREM+1

; number of sectors per run (8k blocks)
	LDA #$20
	LDX DISKDNS
	BNE DOIO1
	ASL
DOIO1	STA IOMAX

; setup data address
	LDA #<DATABUF
	STA DATAADR
	LDA #>DATABUF
	STA DATAADR+1

DOIOLP	LDA DISKREM+1
	BNE DOIOL1A	; more than 256 sectors to go
	LDA DISKREM
	BNE DOIOL1	; still sectors to go
	RTS		; finished, return with A=0
DOIOL1	CMP IOMAX
	BCC DOIOL2
DOIOL1A	LDA IOMAX	; >= IOMAX sectors to go, do IOMAX in this loop

DOIOL2	STA SECCNT	; save sector count for this loop
	SEC		; calculate new remaining sectors
	LDA DISKREM
	SBC SECCNT
	STA DISKREM
	BCS DOIOL3
	DEC DISKREM+1

DOIOL3
; calculate number of pages for this block
	LDA SECCNT
	LDX DISKDNS
	BNE DOIOL4	; DD: pages = sectors
	CLC		; SD: pages = (sectors+1)/2
	ADC #1
	LSR

DOIOL4	STA PAGECNT
	
	BPUT0 TRSEC
	LDX $30A
	LDY $30B
	TXA
	ORA $30B	; sector 0?
	BNE DOIOL5	; no, everything's fine
	INX		; output 1 instead
DOIOL5	JSR TODEC
	JSR DEC0SP
	BPUT0A DECBUF+1, 4
	LDA #':
	JSR PUTCHAR

	LDA IODIR
	BEQ DOIOL6	; skip reading flash

; read data from flash
	JSR FENABLE
	LDX PAGECNT
	JSR FRPAGE
	JSR FDISABLE

	BPUT0 TWRDSK
	JMP DOIOL7

DOIOL6	BPUT0 TRDDSK

; read/write sectors from/to disk
DOIOL7	JSR SECIO
	BPL DOIOL8
	BPUT0 TERRS
	LDX $30A
	LDY $30B
	JSR PRDEC 
	JMP DOCONT

DOIOL8	LDA IODIR
	BNE DOIOL9

; write flash
	JSR PPROGF
	JSR FENABLE
	LDX PAGECNT
	JSR FWPAGE
	PHP
	JSR FDISABLE
	PLP
	BPL DOIOL9
	JSR PERRADR
	JMP DOCONT

DOIOL9	JSR POK

DOIOL10

; increment flash address
	CLC
	LDA FLASHADR+1
	ADC PAGECNT
	STA FLASHADR+1
	BCC DOIOL11
	INC FLASHADR+2
DOIOL11	JMP DOIOLP

; add a disk

ADDDISK	LDA DISKIDX
	CMP #CTTSIZE
	BCC ADDOK

	BPUT0 TFULL
	JMP DOCONT

ADDOK	LDA #155
	JSR PUTCHAR
	JSR GETDRVN

	JSR GETDENS
	BPL ADDD1
	BPUT0 TDNERR
	JMP DOCONT

; print disk info
ADDD1	LDX DISKSEC		; number of sectors
	LDY DISKSEC+1
	JSR PRDEC

	LDA #32
	JSR PUTCHAR

	LDA #'S
	LDX DISKDNS
	BEQ ADDD2
	LDA #'D
ADDD2	JSR PUTCHAR

	BPUT0 TSECT

; calculate image size
	LDA DISKDNS
	LDX DISKSEC
	LDY DISKSEC+1
	JSR CALCSIZ
	MCMP32 DISKSIZ,IMGFREE
	BCC ADDD3
	BEQ ADDD3

	BPUT0 TBIG
	JMP DOCONT

; input disk name
ADDD3	BPUT0 TDNAM
	INPUT 0, NAMBUF
	BPL ADDD4
	JMP DOCONT
; check for EOL
ADDD4	LDX #0
ADDD5	LDA NAMBUF,X
	CMP #155
	BEQ ADDD6
	INX
	CPX #CLNNAME
	BNE ADDD5
	DEX
	LDA #155
	STA NAMBUF,X
ADDD6	INX			; fill rest of name buffer with $FF
	CPX #CLNNAME
	BEQ ADDD7
	LDA #$FF
	STA NAMBUF,X
	BNE ADDD6		; always

; setup drive table
ADDD7	LDX DISKIDX
	LDA #0
	STA TABBUF+CTOACTI,X	; slot active
	LDA DISKDNS
	STA TABBUF+CTODENS,X	; disk density
	LDA DISKOFS+1
	STA TABBUF+CTOSPL,X	; starting page lo
	LDA DISKOFS+2
	STA TABBUF+CTOSPH,X	; starting page hi
	LDA DISKSEC
	STA TABBUF+CTOSECL,X	; sectors lo
	LDA DISKSEC+1
	STA TABBUF+CTOSECH,X	; sectors hi

; clear first 1k of buffer with $FF
	LDX #0
	LDA #$FF
ADDD8	STA DATABUF,X
	STA DATABUF+$100,X
	STA DATABUF+$200,X
	STA DATABUF+$300,X
	INX
	BNE ADDD8

; setup virtual sector 0
; status data
	LDX #3
ADDD9	LDA STATBUF,X
	STA DATABUF+COFSTAT,X
	DEX
	BPL ADDD9
; percom block
	LDX #11
ADDD10	LDA PERCBUF,X
	STA DATABUF+COFPERC,X
	DEX
	BPL ADDD10

; image name
	LDX #CLNNAME-1
ADDD11	LDA NAMBUF,X
	STA DATABUF+COFNAME,X
	DEX
	BPL ADDD11

; now update the disk image table
	BPUT0 TPTAB
	JSR PPROGF
	JSR SETTABA
; only write image infos, but don't mark image as active yet
	JSR FENABLE
	LDY DISKIDX
	INY		; skip active flag
	LDX #[CTESIZE-1]	; program 7 bytes
	JSR FWBYTE
	PHP
	JSR FDISABLE
	PLP
	BPL ADDD12
	JSR PERRADR
	JMP DOCONT

ADDD12	JSR POK

; setup flash address
	LDX #2
ADDD12A	LDA DISKOFS,X
	STA FLASHADR,X
	DEX
	BPL ADDD12A

	LDX #0		; program flash
	JSR DOIO
	BPL ADDD13
	JMP DOCONT

ADDD13
; finished, now mark the image as active
	BPUT0 TPTABF

	JSR PPROGF
	JSR SETTABA
; only write image infos, but don't mark image as active yet
	JSR FENABLE
	LDY DISKIDX
	LDX #1		; program 1 byte (active flag)
	JSR FWBYTE
	PHP
	JSR FDISABLE
	PLP
	BPL ADDD14
	JSR PERRADR
	JMP DOCONT

ADDD14	JSR POK
	JMP DOCONTS	


; write image to disk
WRDISK	BPUT0 TIMGNO
WRDISKI	JSR GETCHAR
	CPY #128
	BNE WRDISK1
	JMP DOCONT

WRDISK1	CMP #'1
	BCC WRDISKI
	CMP #'9
	BCS WRDISKI
	PHA
	JSR PUTCHAR
	PLA
	SEC
	SBC #'1
	TAX

; multiply image number by CTESIZE
	LDA #0
WRDISK2	CPX #0
	BEQ WRDISK2A
	CLC
	ADC #CTESIZE
	DEX
	BCC WRDISK2	; always

WRDISK2A
	STA DISKIDX
	TAX

	LDA TABBUF+CTODENS,X
	STA DISKDNS
	BPL WRDISK3	; OK, active slot

WRDINV	BPUT0 TINVIMG
	JMP DOCONT

WRDISK3	LDA TABBUF+CTOACTI,X
	BNE WRDINV	; invalid image

	LDA TABBUF+CTOSECL,X
	STA DISKSEC
	LDA TABBUF+CTOSECH,X
	STA DISKSEC+1

	JSR GETDRVN
	JSR GETSTAT
	BPL WRDISK4

	BPUT0 TNODISK
	JMP DOCONT

WRDISK4	LDA #1
	STA WRFMT	; default: format disk
	BPUT0 TFORMD
	JSR YESNO
	BMI WRDISK4X
	BEQ WRDISK41
	DEC WRFMT	; no = don't format disk
WRDISK41
	BPUT0 TINSER
	JSR GETCHAR
	CPY #128
	BNE WRDISK5

WRDISK4X
	JMP DOCONT

WRDISK5	

; get percom block of image
	LDX DISKIDX
	LDA #COFPERC
	STA FLASHADR
	LDA TABBUF+CTOSPL,X
	STA FLASHADR+1
	LDA TABBUF+CTOSPH,X
	STA FLASHADR+2
	LDA #<PERCIMG
	STA DATAADR
	LDA #>PERCIMG
	STA DATAADR+1
	JSR FENABLE
	LDY #0
	LDX #12
	JSR FRBYTE
	JSR FDISABLE

	LDA #155
	JSR PUTCHAR
	LDA #155
	JSR PUTCHAR

	LDA WRFMT	; format disk ?
	BEQ WRDISK6	; no, skip format
	BPUT0 TFORMT
	
; format the disk
	JSR FMTDISK
	PHP
	JSR PSTAT
	PLP
	BPL WRDISK6
WRDISKX	JMP DOCONT

WRDISK6	LDA #0
	STA $30A
	STA $30B
	STA FLASHADR

	LDX #1
	JSR DOIO
	BPL WRDISK7
	JMP DOCONT
WRDISK7	JMP DOCONTS

INIT	LDA 106
	STA M106
	LDA 740
	STA M740
	LDA #$80
	STA 106
	STA 740
	JSR GR0

	LDA $D301
	STA MD301
	ORA #2
	STA $D301
	RTS

CLEANUP	LDA MD301
	STA $D301
	LDA M106
	STA 106
	LDA M740
	STA 740
	JMP GR0

M106	.BYTE 0
M740	.BYTE 0
MD301	.BYTE 0

MOVDATA
	LDA RUNMODE
	BEQ NOROMCP

	JSR FENABLE

; copy cartridge code from ROM
	LDA #<OFSCODL
	STA FLASHADR
	LDA #>OFSCODL
	STA FLASHADR+1
	LDA #OFSCODH
	STA FLASHADR+2
	LDA #<CARTCOD
	STA DATAADR
	LDA #>CARTCOD
	STA DATAADR+1
	LDX #$20
	JSR FRPAGE

	JSR FDISABLE

NOROMCP
	JSR CODPUT	; put cartridge code into place

; enable highspeed SIO
	LDA #<HIADR
	STA SIOVEC+1
	LDA #>HIADR
	STA SIOVEC+2

; clear highspeed SIO table
	LDA #0
	STA $301
	JMP HIADR

SIOVEC	JMP HIADR

; copy cartridge code to safe (original) address
CODSAV	LDA #<CCADR
	STA SRCVEC
	LDA #>CCADR
	STA SRCVEC+1
	LDA #<CARTCOD
	STA DSTVEC
	LDA #>CARTCOD
	STA DSTVEC+1
	LDX #$20	; $20 pages = 8k
	JMP COPYPAG

; copy cartridge code from safe (original) to final address
CODPUT	
	LDA #<CARTCOD
	STA SRCVEC
	LDA #>CARTCOD
	STA SRCVEC+1
	LDA #<CCADR
	STA DSTVEC
	LDA #>CCADR
	STA DSTVEC+1
	LDX #$20	; $20 pages = 8k
	JMP COPYPAG

; copy X pages from srcvec to dstvec
COPYPAG	LDY #0
COPYPLP	LDA (SRCVEC),Y
	STA (DSTVEC),Y
	INY
	BNE COPYPLP
	INC SRCVEC+1
	INC DSTVEC+1
	DEX
	BNE COPYPLP
	RTS

DETECT	
.if .def MEGAMAX8
; support RAM mode
	LDA RAMMODE
	BNE DETECT0
	LDA #TRAM1024
	JSR FSETCHP
	JMP DETECT1
DETECT0
; detect second flash chip at $080000
	LDA #8
	STA FLASHADR+2
	JSR FDETECT

	LDA FTYPE
	STA FTYPE2
	LDA #0
	STA FLASHADR+2
.endif
	JSR FDETECT
	JSR FDISABLE

.if .def MEGAMAX8
	LDA FTYPE
	CMP FTYPE2
	BEQ AFOK
	BPUT0 TAFERR
	LDA #$FF
	STA FTYPE
	RTS
AFOK
.endif

DETECT1	LDA FTYPE
	JSR PFTYPE	; print flash type

	LDA FTYPE
	BPL DETCHK	; detected a chip?
	RTS		; no, skip compatibility checks

DETCHK

; detection OK, now check if chip is compatible with software

.if .def MEGAMAX8 .or .def MEGA512
; in case of RAMMODE just return
	LDA RAMMODE
	BEQ DETXIT
; we are doing chip erase, so just check if the flash size is 512k
	LDA FSIZE
	ORA FSIZE+1
	BNE DETERR
	LDA FSIZE+2
	CMP #8
	BNE DETERR
DETXIT	RTS
.endif

.if .def MEGA4096
; in case of RAMMODE just return
	LDA RAMMODE
	BEQ DETXIT
; we are doing chip erase, so just check if the flash size is 4MB
	LDA FSIZE
	ORA FSIZE+1
	BNE DETERR
	LDA FSIZE+2
	CMP #64
	BNE DETERR
DETXIT	RTS
.endif

.if .def FREEZER2005
; we have to do block erase, so check if the flash size is 512k
; and the flash consists of 8*64k blocks
	LDA FSIZE
	ORA FSIZE+1
	ORA FBLKSIZ
	ORA FBLKSIZ+1
	BNE DETERR
	LDA #8
	CMP FSIZE+2
	BNE DETERR
	CMP FNUMBLK
	BNE DETERR
	LDA FBLKSIZ+2
	CMP #1
	BNE DETERR
.endif
	RTS

DETERR	BPUT0 TUNSUP
	LDA #$FF
	STA FTYPE
	RTS

; erase flash chip(s)

ERASE	JSR FADRZERO
	JSR FENABLE

.if .def FREEZER2005
; erase 7*64k blocks, combine status resulsts
	LDA #0
	STA TMP32

ERASELP	JSR FPERAS
	PHP
	PLA
	ORA TMP32
	STA TMP32
	INC FLASHADR+2
	LDA FLASHADR+2
	CMP #7
	BNE ERASELP

	JSR FDISABLE

	LDA TMP32
	PHA
	PLP
	RTS

.else
	JSR FCERAS

.if .def MEGAMAX8
; also erase second chip, combine status results
	PHP
	PLA
	STA TMP32
	LDA #8
	STA FLASHADR+2
	JSR FCERAS
	PHP
	PLA
	ORA TMP32
	PHA
	PLP
ERASE2
.endif	; MEGAMAX8
	PHP

	JSR FDISABLE

	PLP
	RTS
.endif	; FREEZER2005


TFA10	.BYTE "Flash:", $99
	.BYTE +$80,"AMD 29F010"
	.BYTE $19,155

TFA10B	.BYTE "Flash:", $99
	.BYTE +$80,"AMD 29F010B"
	.BYTE $19,155

TFA40B	.BYTE "Flash:", $99
	.BYTE +$80,"AMD 29F040B"
	.BYTE $19,155

TFA32B	.BYTE "Flash:", $99
	.BYTE +$80,"AMD 29F032B"
	.BYTE $19,155

TFS10B	.BYTE "Flash:", $99
	.BYTE +$80,"ST 29F010B"
	.BYTE $19,155

TFS40B	.BYTE "Flash:", $99
	.BYTE +$80,"ST 29F040B"
	.BYTE $19,155

TFB40	.BYTE "Flash:", $99
	.BYTE +$80,"BM 29F040"
	.BYTE $19,155

TFR128	.BYTE "RAM:", $99
	.BYTE +$80,"128k"
	.BYTE $19,155

TFR512	.BYTE "RAM:", $99
	.BYTE +$80,"512k"
	.BYTE $19,155

TFR1024	.BYTE "RAM:", $99
	.BYTE +$80,"1024k"
	.BYTE $19,155

TUNKFL	.BYTE "No or unknown flash",155

TUNSUP	.BYTE "sorry, this chip is not supported"
TUNSUPL	= * - TUNSUP

; print flash type
PFTYPE	CMP #TAMD10
	BNE PFTYPE1
	PRINT0 TFA10
	RTS
PFTYPE1	CMP #TAMD10B
	BNE PFTYPE2
	PRINT0 TFA10B
	RTS
PFTYPE2	CMP #TAMD40B
	BNE PFTYPE3
	PRINT0 TFA40B
	RTS
PFTYPE3	CMP #TST10B
	BNE PFTYPE4
	PRINT0 TFS10B
	RTS
PFTYPE4	CMP #TST40B
	BNE PFTYPE5
	PRINT0 TFS40B
	RTS
PFTYPE5	CMP #TBM40
	BNE PFTYPE6
	PRINT0 TFB40
	RTS
PFTYPE6	CMP #TRAM128
	BNE PFTYPE7
	PRINT0 TFR128
	RTS
PFTYPE7	CMP #TRAM512
	BNE PFTYPE8
	PRINT0 TFR512
	RTS
PFTYPE8	CMP #TRAM1024
	BNE PFTYPE9
	PRINT0 TFR1024
	RTS
PFTYPE9	CMP #TAMD32B
	BNE PFTYPE10
	PRINT0 TFA32B
	RTS

PFTYPE10	PRINT0 TUNKFL
	RTS

; print flash address
PFLADR	LDA #$99
	JSR PUTCHAR
	LDA FLASHADR+2
	JSR PUTHEXI
	LDA FLASHADR+1
	JSR PUTHEXI
	LDA FLASHADR+0
	JSR PUTHEXI
	LDA #$19
	JSR PUTCHAR
	LDA #155
	JMP PUTCHAR

; print error plus internal flash address
PERRADR	BPUT0 TERRADR
	LDA FLASHADI+2
	JSR PUTHEX
	LDA FLASHADI+1
	JSR PUTHEX
	LDA FLASHADI
	JSR PUTHEX
	LDA #155
	JMP PUTCHAR

; print "flash"
PPROGF	BPUT0 TPROGF
	RTS

RUNMODE	.BYTE 0

; 0 = RAM, $FF = flash
RAMMODE	.BYTE 0

DISKIDX	.BYTE 0
DISKOFS	.WORD 0,0

; 32bit image space end address
IMGEND	.WORD OFSIMEL, OFSIMEH

; 32bit number of free image bytes
IMGFREE	.WORD 0,0

; temporary 32bit storage
TMP32	.WORD 0,0

; temporary index
TMPIDX	.BYTE 0

; flag: format disk on writing
WRFMT	.BYTE 0

TTITLE
.if .def MEGA512
	.BYTE 125, "Mega 512k FlashCart DiskWriter V1.20",155
.endif
.if .def MEGA4096
	.BYTE 125, "4MB Mega FlashCart DiskWriter V1.20",155
.endif
.if .def MEGAMAX8
	.BYTE 125, "Atari/MegaMax 1024k DiskWriter V1.20",155
.endif
.if .def FREEZER2005
	.BYTE 125, "Turbo Freezer 2005 DiskWriter V1.20",155
.endif
.if .def FREEZER2011
	.BYTE 125, "Turbo Freezer 2011 DiskWriter V1.20",155
.endif
.BYTE "(c) 2013 by Matthias Reichl",155,155
TTITLEL	= * - TTITLE


TMENU	.BYTE 155,155
.if .def FREEZER2005 .or .def FREEZER2011
	.BYTE "1) Init CartEmu",155
.else
	.BYTE "1) Init flash cartridge",155
.endif
	.BYTE "2) Add disk to cart",155
	.BYTE "3) Write image to disk",155
	.BYTE "4) Toggle HISIO on/off",155
	.BYTE "5) Start cartridge",155
	.BYTE "0) Exit program",155
	.BYTE "> "
TMENUL	= * - TMENU

TNOCAR	
.if .def MEGAMAX8
	.BYTE "no cart detected - check switch"
.else
.if .def FREEZER2005 .or .def FREEZER2011
	.BYTE "no cartemu detected - check switch"
.else
	.BYTE "no cart detected!"
.endif
.endif
TNOCARL	= * - TNOCAR

.if .def MEGAMAX8
TASKRM	.BYTE 155, "run in RAM mode (y/n)? "
TASKRML	= * - TASKRM
.endif


TNOINI	.BYTE 155, "cart uninitialized!"
TASKIN

.if .def FREEZER2005 .or .def FREEZER2011
	.BYTE 155, "Initialize CartEmu (y/n)? "
.else
	.BYTE 155, "Initialize flash cart (y/n)? "
.endif
TASKINL	= * - TASKIN
TNOINIL	= * - TNOINI

TASKAU	.BYTE 155, "Autostart MyPicoDos (y/n)? "
TASKAUL	= * - TASKAU

TASKSC	.BYTE 155, 155, "Start cartridge (y/n)? "
TASKSCL	= * - TASKSC

TDNAM	.BYTE "disk name > "
TDNAML	= * - TDNAM

TINSER	.BYTE 155, "insert disk, press any key"
TINSERL	= * - TINSER

TFORMT	.BYTE "formatting disk"
TFORMTL	= * - TFORMT

TERRADR	.BYTE 155, "Error at address $"
TERRADRL = * - TERRADR

TERAS	.BYTE " erase"
TERASL	= * - TERAS

TRDDSK	.BYTE " read"
TRDDSKL	= * - TRDDSK

TWRDSK	.BYTE " write"
TWRDSKL	= * - TWRDSK

TPROGF	.BYTE " flash"
TPROGFL	= * - TPROGF

TFINI	.BYTE 155, "operation successfully completed",155
TFINIL	= * - TFINI

TCONT	.BYTE 155
	.BYTE "Press any key to continue > "
TCONTL	= * - TCONT

TVERS	.BYTE "Software:", $99
TVERSL	= * - TVERS

THISIO	.BYTE " HiSIO:", $99
	.BYTE +$80, "o"
THISIOL	= * - THISIO

; signature in cartridge
TSIG	.BYTE "HiassofT"

TFREE	.BYTE "k free"
TFREEL	= * - TFREE

TIMG	.BYTE "stored images:",155
TIMGL	= * - TIMG

TINACT	.BYTE +$80, "incomplete data"
	.BYTE 155
TINACTL	= * - TINACT

TDRVNO	.BYTE 155, "enter drive number (1-8) >"
TDRVNOL	= * - TDRVNO

TIMGNO	.BYTE 155, 155, "enter image number (1-8) >"
TIMGNOL	= * - TIMGNO

TINVIMG	.BYTE 155, 155, "invalid image number!",155
TINVIMGL = * - TINVIMG

TFORMD	.BYTE "format disk (y/n)? "
TFORMDL	= * - TFORMD

TDNERR	.BYTE "Error checking disk density",155
TDNERRL	= * - TDNERR

TNODISK	.BYTE "Drive not responding",155
TNODISKL = * - TNODISK

TSECT	.BYTE "D sectors",155
TSECTL	= * - TSECT

TBIG	.BYTE "not enough free space for disk",155
TBIGL	= * - TBIG

TFULL	.BYTE "image table full (max. 8)",155
TFULLL	= * - TFULL

TINIT	.BYTE 155, 155
	.BYTE "init cart:"
TINITL	= * - TINIT

TPTAB	.BYTE 155
	.BYTE "update slot:"
TPTABL	= * - TPTAB

TPTABF	.BYTE "     finish:"
TPTABFL	= * - TPTABF

TRSEC	.BYTE "sector "
;	.BYTE "sector 1234: "
TRSECL	= * - TRSEC

TERRS	.BYTE 155, "Error at sector "
TERRSL	= * - TERRS

.if .def MEGAMAX8
FTYPE2	.BYTE 0

TAFERR	.BYTE "Chip mismatch or defect!",155
TAFERRL	= * - TAFERR
.endif

AUTOFLG	.BYTE 0

	.include "iohelp.src"
	.include "diskio.src"
	.include "arith.src"

	.include "libflash.src"

DCODEL	= * - START

	.bank
	* = (*+255) & $FF00

; buffer for image name
NAMBUF	* = * + 128

; drive table (8 entries of 8 bytes each)
TABBUF	* = * + $40

	* = (*+255) & $FF00

SECBUF	* = * + $100
DATABUF = *

	.bank

CARTCOD
.if .def MEGA512
	.incbin "mypdos-mega512.rom"
.endif
.if .def MEGA4096
	.incbin "mypdos-mega4096.rom"
.endif
.if .def MEGAMAX8
	.incbin "mypdos-megamax.rom"
.endif
.if .def FREEZER2005
	.incbin "mypdos-freezer05.rom"
.endif
.if .def FREEZER2011
	.incbin "mypdos-freezer11.rom"
.endif
CARTCODL = * - CARTCOD

	.BANK
	* = $2E0
	.WORD EXESTART

