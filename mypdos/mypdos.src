;  MyPicoDos 4.05 - main menu and loader routine
;
;  Copyright (C) 1992-2011 Matthias Reichl <hias@horus.com>
;
;  This program is free software; you can redistribute it and/or modify
;  it under the terms of the GNU General Public License as published by
;  the Free Software Foundation; either version 2 of the License, or
;  (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; if not, write to the Free Software
;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

	.include "common.inc"
	.include "cio.inc"

	.if .def HWDEBUG
	.include "hwdebug.src"
	.endif

	.IF .NOT .DEF DEFDRIVE
	DEFDRIVE=1
	.ENDIF

; default highspeed mode
; $00 = off
; $01 = auto (enable after booting)
; $81 = enable during booting

	.if .not .def HIDEF
	HIDEF=$81
	.endif

; default pokey divisor for SDrive
	.if .not .def SDDEF
	SDDEF=0
	.endif

	PICOSTART = $1000

	.OPT NO OBJ

	.include "rreadcode.src"
	.include "comloadcode.src"
	.include "basloadcode.src"
	.IF .DEF HIGHSPEED
	.include "hisio.inc"
	SIOADR = COMLEND
	.include "highspeedcode.src"
	.ELSE
	.IF .DEF CARTSIO
	.include "cartsio.inc"
	SIOADR = COMLEND
	.include "cartsio.src"
	.ENDIF
	.ENDIF

	.OPT OBJ


; sector number of root directory
ORIGDIR	= $169

; start of data area

BASE	= $3000

FFLAG	= BASE
STSECLO	= BASE+$80
STSECHI	= BASE+$100

SECBUF	= BASE+$200
STACK	= BASE+$300

DIRBUF	= BASE+$400 ; - $C00 / $800 bytes

; misc storage buffer
STORAGE	= BASE+$C00

; format of dirbuf:
; byte  0     ; 1 = regular file, 0 = dir
; bytes 1..11 : filenameext
; bytes 12-13 : start sector low / high

SCREEN	= BASE+$1000

NAMEBUF  = BASE+$2000

NAMEBUFE = BASE+$3400

CLREND	= BASE+$3500

; line separator for PICONAME.TXT
LINESEP	= 155

STACKPTR	= $E0

SADR	= $E2 ; ,$E3
TEMPV	= $E4 ; ,E5
NAMV	= $E6 ; ,E7

TEMP	= $E8

; states for joystick input
JOYSTATE_IDLE		= 0	; idle position
JOYSTATE_MOVE		= 1	; stick just moved
JOYSTATE_TRIGGER	= 2	; trigger pressed, wait for release
JOYSTATE_WAIT_IDLE	= 3	; trigger just released, wait for idle

JOY_DELAY_INITIAL	= 25	; delay before starting key repeat
JOY_DELAY_REPEAT	= 4	; delay in repeating mode

	.MACRO PUSH
	LDX STACKPTR
	STA STACK,X
	INC STACKPTR
	.ENDM

	.MACRO POP
	DEC STACKPTR
	LDX STACKPTR
	LDA STACK,X
	.ENDM

	.IF .DEF MYPDOSATR

	* = PICOSTART-16

;************************************
; ATR file header

	.WORD $0296 ; magic
	.WORD (PICOEND-PICOSTART+15)/16
	.WORD 128
	.WORD 0,0,0,0,0

	.ENDIF ; MYPDOSATR

	* = PICOSTART

	.IF .DEF MYPDOSBIN

;************************************
; boot header complete file

	.BYTE 0

	.if .def MYPDOSATR
	; two-stage load
	.BYTE 3
	.else
	; single-stage load
	.BYTE (PICOEND-PICOSTART+127)/128
	.endif

	.WORD PICOSTART
	.WORD XRTS

	.if .def MYPDOSATR

; two-stage ATR loader

	LDA #$31
	STA $300

	LDA #128
	STA $308
	ASL
	STA $309	; A=0
	STA DSEC+1
	ROL
	STA $301	; A=1
	LDA #4
	STA DSEC
	
	LDA #$52
	STA $302
	LDA #7
	STA $306

	LDA #<(PICOSTART+384)
	STA DBUF
	LDA #>(PICOSTART+384)
	STA DBUF+1

LDRERR
.if .def HIGHSPEED
	LDA #$59
	STA LDSIO+1
	LDA #$E4
	STA LDSIO+2
.endif

LDREST	LDA #$40
	STA $303
LDSIO	JSR $E459
	BMI LDRERR	; switch back to OS SIO and retry on errors

.if .def HIGHSPEED
	; if SELECT is pressed, disable highspeed SIO
	LDA $D01F
	AND #2
	BNE KEEPHF
	STA HIFLG
KEEPHF  BIT HIFLG	; enable highspeed SIO during load?
	BPL LDNOHI	; bit7=0: no -> out of here
	LDA HIAVAIL	; highspeed code completely loaded?
	CMP #$60	; #$60 is RTS
	BNE LDNOHI	; no, still loading
	ASL HIFLG	; mask out enable-during-load bit so we only install
	LSR HIFLG	; the SIO code once
	JSR INSTHI	; copy highspeed code to right location
	LDA #<HISIO	; change SIO vector to highspeed code
	STA LDSIO+1
	LDA #>HISIO
	STA LDSIO+2
LDNOHI
.endif
	INC DSEC
	BNE NLR1
	INC DSEC+1
NLR1	CLC
	LDA DBUF
	ADC #$80
	STA DBUF
	BCC NLR2
	INC DBUF+1
NLR2	DEC BREMAIN
	BNE LDREST

	JMP MENU
BREMAIN	.BYTE ((PICOEND-PICOSTART+127)/128)-3

	.else
	JMP MENU
	.endif


	.if .def HIGHSPEED
HIFLG	.BYTE HIDEF
	.endif

CAUTORUN	.BYTE 0

	.if .def SDRIVE
SDDIV	.BYTE SDDEF
	.endif

	.ELSE	; no MYPDOSBIN
	.IF .DEF MYPDOSROM

	JMP MENU
	.if .def HIGHSPEED
HIFLG	.BYTE HIDEF
	.endif
CAUTORUN	.BYTE 0

	.if .def SDRIVE
SDDIV	.BYTE SDDEF
	.endif

	.ELSE ; no MYPDOSROM

;************************************
; boot header 2-stage boot

	.BYTE 0	; Boot-Block Header
	.BYTE 3	; 3 sectors	
	.WORD PICOSTART
	.WORD XRTS ; Dummy=RTS

	JMP REST

RESTSEC	.WORD 4
RESTBYT	.BYTE 125
RESTMSK	.BYTE 3
RESTLEN	.WORD 128

	.if .def HIGHSPEED
HIFLG	.BYTE HIDEF
	.endif
CAUTORUN	.BYTE 0

	.if .def SDRIVE
SDDIV	.BYTE SDDEF
	.endif

REST	
	LDA #$31
	STA $300

	LDA #1
	STA $301
	
	LDA #$52
	STA $302
	LDA #7
	STA $306

	LDA #<(PICOSTART+384)
	STA DBUF
	LDA #>(PICOSTART+384)
	STA DBUF+1

	LDA RESTLEN
	STA $308
	LDA RESTLEN+1
	STA $309

; read sector 4 so that the XF551 recognizes the disk density

	LDA #4
	STA DSEC
	LDA #0
	STA DSEC+1
	LDA #$40
	STA $303

	JSR $E459

	LDA RESTSEC
	STA DSEC
	LDA RESTSEC+1
	STA DSEC+1

LDRERR
.if .def HIGHSPEED
	LDA #$59
	STA LDSIO+1
	LDA #$E4
	STA LDSIO+2
.endif

LDREST	LDA #$40
	STA $303
LDSIO	JSR $E459
	BMI LDRERR	; switch back to OS SIO and retry on errors

.if .def HIGHSPEED
	; if SELECT is pressed, disable highspeed SIO
	LDA $D01F
	AND #2
	BNE KEEPHF
	STA HIFLG
KEEPHF	BIT HIFLG	; enable highspeed SIO during load?
	BPL LDNOHI	; bit7=0: no -> out of here
	LDA HIAVAIL	; highspeed code completely loaded?
	CMP #$60	; #$60 is RTS
	BNE LDNOHI	; no, still loading
	ASL HIFLG	; mask out enable-during-load bit so we only install
	LSR HIFLG	; the SIO code once
	JSR INSTHI	; copy highspeed code to right location
	LDA #<HISIO	; change SIO vector to highspeed code
	STA LDSIO+1
	LDA #>HISIO
	STA LDSIO+2
LDNOHI
.endif

	LDA DBUF
	STA ADR
	LDA DBUF+1
	STA ADR+1
	LDY RESTBYT
	INY
	INY
	CLC
	LDA DBUF
	ADC (ADR),Y
	STA DBUF
	BCC NLR1
	INC DBUF+1
NLR1	DEY
	LDA (ADR),Y
	STA DSEC
	DEY
	LDA (ADR),Y
	AND RESTMSK
	STA DSEC+1
	ORA DSEC
	BNE LDREST

	.ENDIF	; MYPDOSROM
	JMP MENU
	.ENDIF	; MYPDOSBIN
XRTS	RTS

; highspeed SIO code moved to beginning so that fast 2-stage loading is possible

	.IF .DEF HIGHSPEED
	.include "hisiodet.src"
USSIO	.incbin "highspeed.bin"
USLEN	= * - USSIO

SPEEDTB	.DC 8 0
HIBUF	.DC 4 0

; copy highspeed code to right location
INSTHI	COP768 SIOADR, USSIO, USLEN

; this location is checked by the 2-stage loader.
; If it contains the "RTS" the highspeed code is in memory
; and can be used to speed up further loading
HIAVAIL	RTS

	.ELSE

	.IF .DEF CARTSIO
	.include "mypdos-incbin-cartsio.inc"

INSTCS	LDA $D014
	CMP #$01
	BEQ INSTCSP
; NTSC version
	COP768 SIOADR, CSION, CSIONL
	RTS
INSTCSP
; PAL version
	COP768 SIOADR, CSIOP, CSIOPL
	RTS

	.ENDIF
	.ENDIF


; MyPicoDos display list

; number of screen lines
LINES	= 15

DLIST	.BYTE 112
	.IF .NOT .DEF HIGHSPEED
	.IF .NOT .DEF CARTSIO
	.BYTE 48
	.ENDIF
	.ENDIF
	.IF .NOT .DEF REMOTE
	.BYTE 48
	.ENDIF
	.BYTE $42
	.WORD TITLE
	.BYTE 112,$42
	.WORD DRVLIN
	.BYTE 16,$42
	.WORD TLINE1
	.BYTE 16
	.BYTE $42
SLMS	.WORD SCREEN
	.DC (LINES-1) 2
	.BYTE 16
	.BYTE $42
	.WORD TLINE2
	.BYTE 0,$42
	.WORD TSELECT
	.BYTE 0,2,0,2,0,2

	.IF .DEF HIGHSPEED .OR .DEF CARTSIO
	.BYTE 0,2
	.ENDIF
	.IF .DEF REMOTE
	.BYTE 0,2
	.ENDIF

	.BYTE $41
	.WORD DLIST

; MyPicoDos screen

TITLE	= *
	.IF .DEF BAREBONE
	.SBYTE " MyPicoDos 4.05B (c)"
	.SBYTE " HiassofT 1992-2011 "
	.ELSE
	.IF .DEF THECART
	.SBYTE " MyPicoDos 4.05T (c)"
	.SBYTE " HiassofT 1992-2013 "
	.ELSE
	.IF .DEF REMOTE
	.SBYTE " MyPicoDos 4.05R (c)"
	.SBYTE " HiassofT 1992-2011 "
	.ELSE
	.IF .DEF SDRIVE
	.SBYTE " MyPicoDos 4.05S (c)"
	.SBYTE " HiassofT 1992-2011 "
	.ELSE
	.IF .DEF CARTSIO
	.SBYTE " MyPicoDos 4.05C (c)"
	.SBYTE " HiassofT 1992-2011 "
	.ELSE
	.SBYTE " MyPicoDos 4.05 (c) "
	.SBYTE "HiassofT 1992-2011  "
	.ENDIF
	.ENDIF
	.ENDIF
	.ENDIF

;	        12345678901234567890
TSELECT	.SBYTE "    "
	.SBYTE "use"
	.BYTE 66,222,86
	.BYTE 66,223,86
	.BYTE 66,220,86
	.BYTE 66,221,86
	.BYTE 66
	.SBYTE +$80,"RETURN"
	.BYTE 86
	.SBYTE "to select"
	.SBYTE "    "
	

	.BYTE 66
	.SBYTE +$80,"ESC"
	.BYTE 86
	.SBYTE " = parent DIR"
	.SBYTE "  "
	.BYTE 66
	.SBYTE +$80,"1"
	.BYTE 86
	.SBYTE "-"
	.BYTE 66
	.SBYTE +$80,"8"
	.BYTE 86
	.SBYTE " = D1: - D8: "

	.SBYTE "     "
	.BYTE 66
	.SBYTE +$80,"F"
	.BYTE 86
	.SBYTE " = disk format :"

FORLEN	= 11

DFORMAT	.DC FORLEN 0
	.SBYTE "     "

	.SBYTE "        "
	.BYTE 66
	.SBYTE +$80,"L"
	.BYTE 86
	.SBYTE " = long names :"
LNSTAT	.BYTE 66
	.SBYTE +$80,"AUTO"
	.BYTE 86
	.SBYTE "        "

	.IF .DEF HIGHSPEED

	.SBYTE "      "
	.BYTE 66
	.SBYTE +$80,"H"
	.BYTE 86
	.SBYTE " = high speed"
	.SBYTE " SIO :"
SIOSTAT	.BYTE 66
	.SBYTE +$80,"AUTO"
	.BYTE 86
	.SBYTE "      "

	.ENDIF

	.IF .DEF CARTSIO

	.SBYTE "     "
	.BYTE 66
	.SBYTE +$80,"I"
	.BYTE 86
	.SBYTE " = show images on cartridge"
	.SBYTE "     "

	.ENDIF

	.IF .DEF REMOTE

	.SBYTE "    "
	.BYTE 66
	.SBYTE +$80,"A"
	.BYTE 86
	.SBYTE " = atariserver remote console"
	.SBYTE "    "

	.ENDIF

FORASD	.BYTE 66
	.SBYTE +$80,"AUTO"
	.BYTE 86
	.SBYTE "(SD) "

FORADD	.BYTE 66
	.SBYTE +$80,"AUTO"
	.BYTE 86
	.SBYTE "(DD) "

FORSD	.BYTE 66
	.SBYTE +$80,"SD/DOS2.x"
	.BYTE 86

FORSM	.BYTE 66
	.SBYTE +$80,"SD/MyDOS"
	.BYTE 86
	.SBYTE " "

FORDD	.BYTE 66
	.SBYTE +$80,"DD/DOS2.x"
	.BYTE 86

FORDM	.BYTE 66
	.SBYTE +$80,"DD/MyDOS"
	.BYTE 86
	.SBYTE " "

TAUTO	.BYTE 66
	.SBYTE +$80,"AUTO"
	.BYTE 86

TOFF	.BYTE 66
	.SBYTE +$80,"OFF"
	.BYTE 86,0

;************************************

; file loader code

RREADB	.incbin "rread.bin"
RREADL	= * - RREADB

BASLOAD	.incbin "basload.bin"
BASLEN	= * - BASLOAD

COMLOAD	.incbin "comload.bin"
COMLEN	= * - COMLOAD

;************************************

; start of main selection code

MENU 	= *

	LDX #$FF
	TXS

;	LDX #0
;	LDA #$FF
;CLRSTOR	LDA STORAGE,X
;	INX
;	BNE CLRSTOR

	.if .def HWDEBUG
	TSX
	TXA
	LDX #0
	DBGA
	.endif

	LDA #1
	STA 580
	ORA 9
	STA 9
	LDA #$77
	STA 10
	LDA #$E4
	STA 11

	LDA #JOYSTATE_WAIT_IDLE
	STA JOYSTAT

	COP768 $0800, RREADB, RREADL

	.IF .DEF HIGHSPEED
	JSR INSTHI	; copy SIO code to right location

	LDA HIFLG
	AND #1
	BEQ NODHI
	JSR SPDHI
NODHI
	.ELSE
	.IF .DEF CARTSIO
	JSR INSTCS
	LDA #<SIOADR
	STA NE459+1
	LDA #>SIOADR
	STA NE459+2
	.ENDIF
	.ENDIF

	.IF .DEF SDRIVE
	LDA #$71
	STA $300
	LDA #1
	STA $301
	LDA #$C1
	STA $302
	LDA #0
	STA $303
	LDA SDDIV
	STA $30A
	JSR $E459	; set SDrive pokey divisor
	.IF .DEF HIGHSPEED
	LDA #0
	STA $301
	JSR HISIO	; clear SIO speed table
	.ENDIF
	.ENDIF

	LDA CAUTORUN
	STA AUTORUN

MENU2	LDA 560
	STA OLD560
	LDA 561
	STA OLD560+1
	LDA 710
	STA OLD710

	.IF .DEF HIGHSPEED
	JSR HISTAT
	.ENDIF
	STW 560,DLIST
	LDA #DEFDRIVE
	STA DRIVENO
	STA $301
	LDA #$31
	STA $300

NEWDISK	STW DIRSEC,ORIGDIR
	LDA #0
	STA 710
	STA STACKPTR

;	LDA #$04
;	STA 710
;	STA 712

	JSR CLS

	JSR GETDENS

	LDA SECBYTE
	STA DSKBYT
	LDA $308
	STA DSKLEN
	LDA $309
	STA DSKLEN+1

	LDX DSKFOR

	JSR SETFMT

	JSR PRTFOR

LOOP	JSR SELECT

	LDA FFLAG,X
	BPL STDFIL1

; APE PC-mirror subdirectories are listed with a size of 0 and
; are flagged with a status of $80
; entering them is done by just accessing the first sector of the file

	LDA STSECLO,X
	STA DSEC
	LDA STSECHI,X
	STA DSEC+1
	JSR READSEC

	LDA 20
	CLC
	ADC #20
WCD	CMP 20
	BNE WCD

	JMP LOOP

STDFIL1	AND #$10
	BNE SUBDIR
	LDY SECBYTE
	LDA STSECHI,X
	STA BUF,Y
	LDA STSECLO,X
	INY
	STA BUF,Y

	LDA FFLAG,X
	JSR CHK16

	LDA OLD560
	STA 560
;	STA $D402
	LDA OLD560+1
	STA 561
;	STA $D403
	LDA OLD710
	STA 710
;	STA $D018

	LDA 20
?WT20	CMP 20
	BEQ ?WT20

	JMP LOAD

SUBDIR	STX TEMP
	LDA DIRSEC
	PUSH
	LDA DIRSEC+1
	PUSH
	LDX TEMP
	LDA STSECLO,X
	STA DIRSEC
	LDA STSECHI,X
	STA DIRSEC+1
	JMP LOOP

SELECT	JSR READDIR

	LDA INDUP
	STA TLUP

	.if .def HWDEBUG
	TSX
	TXA
	LDX #2
	DBGA
	.endif

	LDA AUTORUN
	PHA
	LDA #0
	STA XPOS
	STA YPOS
	STA AUTORUN
	PLA
	BEQ NOAUTO

	LDA FILES
	CMP #1
	BNE NOAUTO
	LDX #0
	RTS

NOAUTO	LDA #0
	STA AUTORUN

; directory selection

SELLP	JSR INVERS
GKLP1	JSR GETKEY
	TAX
	TYA
	BMI GKLP1
	TXA
	PHA
	JSR INVERS
	PLA
	CMP #'+
	BNE NCLEFT
YCLEFT	JMP CLEFT
NCLEFT	CMP #30
	BEQ YCLEFT
	CMP #'*
	BNE NCRIGHT
YCRIGHT	JMP CRIGHT
NCRIGHT	CMP #31
	BEQ YCRIGHT
	CMP #'-
	BNE NCUP
YCUP	JMP CUP
NCUP	CMP #28
	BEQ YCUP
	CMP #'=
	BNE NCDOWN
YCDOWN	JMP CDOWN
NCDOWN	CMP #29
	BEQ YCDOWN
	CMP #155
	BNE NCR
	LDA FILES
	BEQ NCR
	JMP RETURN
NCR	CMP #27
	BNE NESC
	LDA STACKPTR
	BEQ SELLP
	POP
	STA DIRSEC+1
	POP
	STA DIRSEC
	JMP SELECT
NESC	= *
	.IF .DEF REMOTE
	CMP #'A
	BNE NKEYA
	PLA
	PLA
	JSR CONSOLE
	JMP MENU2
NKEYA	= *
	.ENDIF
	.IF .DEF CARTSIO
	CMP #'I
	BNE NKEYI
	PLA
	PLA
	JSR IMGINFO
	JMP NEWDISK
NKEYI	= *
	.ENDIF
	.IF .DEF HIGHSPEED
	CMP #'H
	BNE NKEYH
	JMP KEYH
NKEYH	= *
	.ENDIF
	CMP #'1
	BCC NKEY18
	CMP #'9
	BCS NKEY18
	JMP KEY18
NKEY18	CMP #'F
	BNE NKEYF
	JMP KEYF
NKEYF	CMP #'L
	BNE NKEYL
	JMP KEYL
NKEYL	JMP SELLP

CLEFT	LDA LONGFLG
	BNE CLEFTL

	DEC XPOS
	BPL CLOK
	LDA #2
	STA XPOS
	DEC YPOS
	BPL CLOK
GOSTRT	LDA #0
	STA XPOS
	STA YPOS
CLOK	JMP SELLP

CLEFTL	LDA YPOS
	CMP #LINES-1
	BCC GOSTRT
	SBC #LINES-1
	STA YPOS
	JMP SELLP

CRIGHT	LDA LONGFLG
	BNE CRIGHTL

	LDA YPOS
	CMP MAXY
	BEQ CRMY

	INC XPOS
	LDA XPOS
	CMP #3
	BNE CROK
	LDA #0
	STA XPOS
	INC YPOS
	JMP CROK	
CRMY	LDA XPOS
	CMP MAXX
	BEQ CROK
	INC XPOS

CROK	JMP SELLP

CRIGHTL	LDA FILES
	BEQ CROK
	CLC
	LDA YPOS
	ADC #LINES-1
	CMP FILES
	BCC NOTEND
	LDA FILES
	SBC #1
NOTEND	STA YPOS
	JMP SELLP

CUP	LDA YPOS
	BEQ CUOK
	DEC YPOS
CUOK	JMP SELLP

CDOWN	LDA LONGFLG
	BNE CDOWNL

	LDA YPOS
	CMP MAXY
	BEQ CDOK

	INC YPOS
	LDA YPOS
	CMP MAXY
	BNE CDOK

	LDA XPOS
	CMP MAXX
	BCC CDOK
	BEQ CDOK

	LDX MAXY
	DEX
	STX YPOS
CDOK	JMP SELLP

CDOWNL	LDA FILES
	BEQ CDOK2
	CLC
	LDA YPOS
	ADC #1
	CMP FILES
	BEQ CDOK2
	STA YPOS
CDOK2	JMP SELLP

CALCIDX	LDA YPOS
	ASL
	CLC
	ADC YPOS
	CLC
	ADC XPOS
	TAX
	RTS

RETURN	JSR INVERS
	LDA LONGFLG
	BNE RETURNL
	JSR CALCIDX
	CLC
	RTS

RETURNL	LDX YPOS
	CLC
	RTS

KEY18	SEC
	SBC #'0
	STA DRIVENO
	STA $301
	PLA
	PLA
	JMP NEWDISK

	.IF .DEF HIGHSPEED
KEYH	LDA NE459+2
	CMP #$E4
	BEQ HION

	JSR SPDLO
	JMP ENDHI

HION	JSR SPDHI
	LDA #0
	STA $301
	JSR NE459	; clear SIO speed table
	LDA DRIVENO
	STA $301

ENDHI	JSR HISTAT
	JMP SELLP
	.ENDIF

KEYF	LDX DSKFOR
	INX
	CPX #5
	BNE NDFOR0
	LDX #0
NDFOR0	STX DSKFOR
	JSR SETFMT

ENDKEYF	JSR PRTFOR
	JMP SELLP

KEYL	LDA USELONG
	EOR #1
	STA USELONG
	JSR LNGSTAT
	JMP SELECT

	.IF .DEF HIGHSPEED
HISTAT	LDX #5
	LDA NE459+2
	CMP #$E4
	BEQ HIOFF

HALP	LDA TAUTO,X
	STA SIOSTAT,X
	DEX
	BPL HALP
	RTS
HIOFF	LDA TOFF,X
	STA SIOSTAT,X
	DEX
	BPL HIOFF
	RTS
	.ENDIF

LNGSTAT	LDX #5
	LDA USELONG
	BEQ NOULNG
LALP	LDA TAUTO,X
	STA LNSTAT,X
	DEX
	BPL LALP
	RTS
NOULNG	LDA TOFF,X
	STA LNSTAT,X
	DEX
	BPL NOULNG
	RTS

INVERS	LDA LONGFLG
	BNE INVERSL
	JSR SETADRX
	LDY #12
ILP	LDA (SADR),Y
	EOR #$80
	STA (SADR),Y
	DEY
	BPL ILP
	JMP CHKCURS	

INVERSL JSR SETADRY
	LDY #39
ILP2	LDA (SADR),Y
	EOR #$80
	STA (SADR),Y
	DEY
	BPL ILP2
	JMP CHKCURS

SETADRY	LDA YPOS
SETADR	STA SADR
	LDA #0
	STA SADR+1
	ASL SADR
	ROL SADR+1
	ASL SADR
	ROL SADR+1
	ASL SADR
	ROL SADR+1
	LDA SADR
	STA TEMPV
	LDA SADR+1
	STA TEMPV+1
	ASL TEMPV
	ROL TEMPV+1
	ASL TEMPV
	ROL TEMPV+1
	CLC
	LDA SADR
	ADC TEMPV
	STA SADR
	LDA SADR+1
	ADC TEMPV+1
	ADC #>SCREEN
	STA SADR+1
	RTS

SETADRX	JSR SETADRY
	LDX XPOS
	CLC
	LDA XTAB,X
	ADC SADR
	STA SADR
	BCC NSETA1
	INC SADR+1
NSETA1	RTS

; check if cursor position is outside of displayed screen

CHKCURS	LDA YPOS
	CMP SCRY
	BCC CLOW
	CLC
	LDA SCRY
	ADC #LINES-1
	CMP YPOS
	BCC CHIGH
	JMP DISIND

CLOW	LDA YPOS
	STA SCRY
	JSR SETSCR
	JMP DISIND

CHIGH	SEC
	LDA YPOS
	SBC #LINES-1
	STA SCRY
	JSR SETSCR
	JMP DISIND

; set screen address

SETSCR	LDA SCRY
	JSR SETADR
	LDA SADR
	STA SLMS
	LDA SADR+1
	STA SLMS+1
	RTS

; display up/down arrow indicators
DISIND	LDX TLUP
	LDA SCRY
	BEQ NOAUP
	LDX #$5C
NOAUP	STX INDUP
	LDX #$52
	CLC	
	ADC #LINES-1
	CMP MAXY
	BCS NOADWN
	LDX #$5D
NOADWN	STX INDDWN
	RTS

READSEC LDA #$52
	STA $302
	LDA #$40
	STA $303
	LDA #7
	STA $306
	JMP NE459

; if disk format is set to auto, bit 2 of the file status signals
; use of 16 bit sector links
CHK16	LDY DSKFOR
	BNE FMTMAN
	LDY #$03
	AND #4
	BEQ LNK10
	LDY #$FF
LNK10	STY SECMASK
FMTMAN	RTS

READDIR	LDA DIRSEC
	STA DSEC
	LDA DIRSEC+1
	STA DSEC+1
	JSR CLS

	LDA #0
	STA LONGFLG
	STA DIRFILES
	STA NAMESEC
	STA NAMESEC+1
	STA FILES
	STA MAXX
	STA MAXY

	STW DBUF,SECBUF
	STW TEMPV,DIRBUF

	LDA #8
	STA REMAIN
	LDA #$80
	STA MAXFILE

RDDIRLP	JSR READSEC
	BPL DIROK

.if .def HIGHSPEED
	LDA NE459+2
	CMP #$E4
	BEQ DIRERR	; report error if using standard SIO

; disable highspeed SIO and try again
	JSR SPDLO
	JSR READSEC
	BMI RDDERR	; another error

	JSR HISTAT	; read succeeded, stay at standard SIO
	JMP DIROK

RDDERR	JSR SPDHI	; permanent error, enable highspeed again
.endif

DIRERR	JSR CLS
	LDA #0
	STA FILES
	STA MAXX
	STA MAXY
	LDX #DERRLEN-1
DERRLP	LDA DSKERR,X
	STA SCREEN+2,X
	DEX
	BPL DERRLP
	RTS

DIROK	LDA REMAIN
	CMP #8
	BNE NOBIG
	LDA $309
	BEQ NOBIG
	LDA SECBUF+128
	BEQ NOBIG
	LDA #0
	STA MAXFILE

NOBIG	LDX #0
RDFILLP	LDA SECBUF,X
	CMP #0
	BEQ ENDRDIR

	CMP #$10
	BEQ FDIR
	CMP #$30
	BEQ FDIR

	AND #$C3
	CMP #$42
	BEQ FDIR
	CMP #$03
	BNE NOFND

FDIR	JSR FNDENT
	JMP NOFND

NOFND	TXA
	CLC
	ADC #$10
	TAX
	CMP MAXFILE
	BNE RDFILLP

	DEC REMAIN
	BEQ ENDRDIR

	INC DSEC
	BNE NDSEC1
	INC DSEC+1
NDSEC1	JMP RDDIRLP

ENDRDIR	LDA USELONG
	BEQ NONAMES
	LDA NAMESEC
	ORA NAMESEC+1
	BEQ NONAMES

	JSR RDNAMES
	BMI NONAMES
	JSR DISPNAM
	BMI NONAMES
	LDA FILES
	BEQ EMPTYD
	SEC
	SBC #1
	STA MAXY
	LDA #1
	STA LONGFLG
	RTS

NONAMES LDA DIRFILES
	BNE DOSHT

EMPTYD	LDA #0
	STA FILES
	STA MAXX
	STA MAXY

	LDX #DEMPTLEN-1
DEMPTLP	LDA DSKEMPT,X
	STA SCREEN+2,X
	DEX
	BPL DEMPTLP
	RTS

DOSHT	JSR DISPSHT
	JSR CORRECT
	RTS

CHKNAME	STX TEMP
	LDY #0
PSYSC	LDA SECBUF+5,X
	CMP PICOSYS,Y
	BNE NOPSYS
	INX
	INY
	CPY #11
	BNE PSYSC
	LDX TEMP
	SEC
	RTS

NOPSYS	LDX TEMP
	LDY #0
PNAMC	LDA SECBUF+5,X
	CMP PICONAM,Y
	BNE NOPNAM
	INX
	INY
	CPY #11
	BNE PNAMC
	LDX TEMP
	LDA SECBUF+3,X
	STA NAMESEC
	LDA SECBUF+4,X
	STA NAMESEC+1
	LDA SECBUF,X
	JSR CHK16
	SEC
	RTS

NOPNAM	LDX TEMP
	CLC
	RTS

FNDENT	JSR CHKNAME
	BCC NFILOK
	RTS
NFILOK	STX TEMP

	LDY #0
	LDA SECBUF,X
	STA (TEMPV),Y
	AND #$10
	BNE STDFILE

; mark empty files with a status of $80
	LDA SECBUF+1,X
	ORA SECBUF+2,X
	BNE STDFILE
	LDA #$80
	STA (TEMPV),Y
STDFILE INY
NAMCPLP	LDA SECBUF+5,X
	STA (TEMPV),Y
	INX
	INY
	CPY #12
	BNE NAMCPLP

	LDX TEMP
	LDA SECBUF+3,X
	STA (TEMPV),Y
	INY
	LDA SECBUF+4,X
	STA (TEMPV),Y

	CLC
	LDA TEMPV
	ADC #16
	STA TEMPV
	BCC NTINC1
	INC TEMPV+1
NTINC1	INC DIRFILES
	RTS

; display directory in short format

EMPTY1	RTS

DISPSHT	STW TEMPV,DIRBUF
	STW SADR1,SCREEN
	LDA #0
	STA FILES
	LDA DIRFILES
	BEQ EMPTY1

DISPLP1	LDY #0
	LDX FILES
	LDA (TEMPV),Y
	STA FFLAG,X
	LDY #12
	LDA (TEMPV),Y
	STA STSECLO,X
	INY
	LDA (TEMPV),Y
	STA STSECHI,X

	LDX MAXX
	CLC
	LDA XTAB,X
	ADC SADR1
	STA SADR
	LDA SADR1+1
	ADC #0
	STA SADR+1

	LDY #0
	LDA (TEMPV),Y
	BMI PCMDIR
	AND #$10
	BEQ REGFILE
	LDA #30
	STA (SADR),Y
	BNE REGFILE

PCMDIR	LDA #60
	STA (SADR),Y
	
REGFILE	INY

DISPLP2	LDA (TEMPV),Y
	JSR INTERNAL
	STA (SADR),Y
	INY
	CPY #12
	BNE DISPLP2

	CLC
	LDA TEMPV
	ADC #16
	STA TEMPV
	BCC NTV1
	INC TEMPV+1

NTV1	INC FILES
	INC MAXX
	LDA MAXX
	CMP #3
	BNE NIMY1
	INC MAXY
	LDA #0
	STA MAXX
	CLC
	LDA SADR1
	ADC #40
	STA SADR1
	BCC NIMY1
	INC SADR1+1

NIMY1	LDA FILES
	CMP DIRFILES
	BEQ SHTEND
	JMP DISPLP1
SHTEND	LDX TEMP
	RTS

CORRECT	DEC MAXX
	BPL ENDCOR
	LDA #2
	STA MAXX
	DEC MAXY
ENDCOR	RTS

RDNAMES	LDA NAMESEC
	STA DSEC
	LDA NAMESEC+1
	STA DSEC+1
	LDA #<NAMEBUF
	STA DBUF
	STA TEMPV
	LDA #>NAMEBUF
	STA DBUF+1
	STA TEMPV+1

RDNAMLP	LDA #$40
	STA $303
	JSR NE459
	BMI NAMERR

	LDY SECBYTE
	LDA (TEMPV),Y
	AND SECMASK
	STA DSEC+1
	INY
	LDA (TEMPV),Y
	STA DSEC
	INY
	CLC
	LDA DBUF
	ADC (TEMPV),Y
	STA DBUF
	STA TEMPV
	LDA DBUF+1
	ADC #0
	STA DBUF+1
	STA TEMPV+1

	LDA DSEC
	ORA DSEC+1
	BEQ RDNEND

	LDA DBUF+1
	CMP #>(NAMEBUFE)
	BNE RDNAMLP

RDNEND	LDA TEMPV
	STA NAMEEND
	LDA TEMPV+1
	STA NAMEEND+1

; sentinel
	LDA #155
	STA NAMEBUF-1

; check for line separator at end of PICONAME.TXT
	LDA TEMPV
	BNE RDN1
	DEC TEMPV+1
RDN1	DEC TEMPV
	LDY #0
	LDA (TEMPV),Y
	CMP #LINESEP
	BEQ LSEPOK
	INY
	LDA #LINESEP
	STA (TEMPV),Y
	INC NAMEEND
	BNE LSEPOK
	INC NAMEEND+1
LSEPOK	LDA #0
NAMERR	RTS

	.include "longname.src"

; find FILNAM in DIRBUF
; if found, set FFLAG, STSECLO, STSECHI
; but do not increment FILES

FINDFIL	STW TEMPV,DIRBUF
	LDA #0
	STA DIRCNT
FINDLP	LDA DIRCNT
	CMP DIRFILES
	BEQ NOFFND
	LDY #1
FCMPLP	LDA (TEMPV),Y
	CMP FILNAM-1,Y
	BNE NEXTFIL
	INY
	CPY #12
	BNE FCMPLP
	LDX FILES
	LDA (TEMPV),Y
	STA STSECLO,X
	INY
	LDA (TEMPV),Y
	STA STSECHI,X
	LDY #0
	LDA (TEMPV),Y
	STA FFLAG,X
	LDA #0
	RTS

NEXTFIL	CLC
	LDA TEMPV
	ADC #16
	STA TEMPV
	BCC NTV2
	INC TEMPV+1
NTV2	INC DIRCNT
	JMP FINDLP

NOFFND	LDY #1
	RTS

DISPNAM	STW NAMV,NAMEBUF
	STW SADR,SCREEN
	JSR GETLNG
	BMI DISPERR
	CPX #0
	BEQ NOTITLE

	CPX #38
	BCC TITLOK
	LDX #38
TITLOK	STX TEMP
	SEC
	LDA #38
	SBC TEMP
	LSR
	TAX
	LDY #0
	LDA #$44
	STA TLINE1,X
	INX
DNAMLP	LDA LONGNAM,Y
	JSR INTERNAL
	STA TLINE1,X
	INY
	INX
	DEC TEMP
	BNE DNAMLP
	LDA #$41
	STA TLINE1,X

NOTITLE	= *

DISLP1	JSR GETFNAM
	BMI DISPEND
	JSR GETLNG
	BMI DISPERR
	CPX #0
	BEQ DISLP1
	JSR FINDFIL
	BNE DISLP1
	LDY #38
DISLP2	LDA LONGNAM-1,Y
	JSR INTERNAL
	STA (SADR),Y
	DEY
	BNE DISLP2
	CLC
	LDA SADR
	ADC #40
	STA SADR
	BCC NSA1
	INC SADR+1
NSA1	INC FILES
	LDA FILES
	CMP #100
	BCC DISLP1
DISPEND	LDY #0
	RTS
DISPERR	LDY #$FF
	RTS

CLS	LDY #39
CLSLP1	LDA #$52
	STA TLINE1,Y
	STA TLINE2,Y
	LDA #0
	STA DRVLIN,Y
	DEY
	BPL CLSLP1

	LDA #66
	STA DSKOFS
	LDA #$A4
	STA DSKOFS+1
	CLC
	LDA DRIVENO
	ADC #$90
	STA DSKOFS+2
	LDA #$9A
	STA DSKOFS+3
	LDA #86
	STA DSKOFS+4

	LDA #>SCREEN
	STA TEMP+1
	LDA #0
	STA TEMP
	TAY
	LDX #$10
CLSLP2	STA (TEMP),Y
	DEY
	BNE CLSLP2
	INC TEMP+1
	DEX
	BNE CLSLP2
	STA SCRY
	JMP SETSCR

; read stick 1+2 into X and trig 1+2 into Y
GETJOY	LDA 632
	AND 633
	TAX
	LDA 644
	AND 645
	TAY
	RTS

; joystick direction table:
; 0 (idle), 1 (up), 2 (down), 3 (left), 4 (right), $80 (invalid)
JDIRTAB
	.BYTE $80, $80, $80, $80
	.BYTE $80, $80, $80, 4
	.BYTE $80, $80, $80, 3
	.BYTE $80, 2, 1, 0

; keys for up/down/left/right
JKEYTAB	.BYTE 14, 15, 6, 7

GETKEY	LDA 764
	CMP #255
	BEQ GETKJ
	LDX #JOYSTATE_WAIT_IDLE	; just in case
	STX JOYSTAT

DOGETK	STA 764
; disable atract mode
	LDA #0
	STA 77
	LDA $E425
	PHA
	LDA $E424
	PHA
	RTS

; handle joystick input
GETKJ
.if .def HWDEBUG
	LDA JOYSTAT
	LDX #4
	DBGA
	JSR GETJOY
	TYA
	LSR
	TXA
	BCC DBGT0
	ORA #$10
DBGT0	LDX #6
	DBGA
.endif
	JSR GETJOY
	LDA JOYSTAT
	CMP #JOYSTATE_WAIT_IDLE
	BNE GETKJS1

; handle wait idle:
; trigger down switches to trigger state
; otherwise wait for joystick idle to enter idle state

	CPY #0
	BEQ JS_GO_TRIGGER
; wait idle: only leave this state if stick and trig are released
	CPX #15
	BNE GETKEY

JS_GO_IDLE
	LDA #JOYSTATE_IDLE
	STA JOYSTAT
	JMP GETKEY

GETKJS1	CMP #JOYSTATE_IDLE
	BNE GETKJS2

; handle idle state
	CPY #0
	BNE GETKJ11	; branch if trigger released

; trigger pressed, enter TRIGGER state
JS_GO_TRIGGER
	LDA #JOYSTATE_TRIGGER
	STA JOYSTAT
	JMP GETKEY

GETKJ11	LDY JDIRTAB,X
	BEQ GETKEY	; nothing to do if idle
	BMI GETKEY	; nothing to do if invalid

	STX OLDJOY	; save joystick direction
	LDA #JOYSTATE_MOVE
	STA JOYSTAT
	LDA #JOY_DELAY_INITIAL

JS_SEND_KEY
	STA WTJOY
	LDA 20
	STA OLD20
	LDA JKEYTAB-1,Y	; translate direction into key
	JMP DOGETK

GETKJS2	CMP #JOYSTATE_MOVE
	BNE GETKJS3

; handle move state
	CPY #0
	BEQ JS_GO_TRIGGER
	CPX OLDJOY
	BNE JS_GO_IDLE	; stick position changed, go to idle mode

	LDA 20
	CMP OLD20
	BNE GETKJ21
GETKJ20
	JMP GETKEY
GETKJ21
	STA OLD20

	DEC WTJOY
	BNE GETKJ20	; countdown not reached yet

	LDY JDIRTAB,X
	LDA #JOY_DELAY_REPEAT
	JMP JS_SEND_KEY

GETKJS3	CMP #JOYSTATE_TRIGGER
	BNE GETKJS4

; handle trigger pressed state
	CPY #1
	BEQ GETKJ31	; branch if trigger released
GETKJ30
	JMP GETKEY	; otherwise wait

; trigger released, check what to do
GETKJ31	LDA #JOYSTATE_WAIT_IDLE
	STA JOYSTAT	; in all situations, transition to wait idle
	LDY JDIRTAB,X
	BMI GETKJ30	; invalid position, do nothing
	BNE GETKJ32	; branch if not idle
; idle position: send return
	LDA #12
	JMP DOGETK
GETKJ32	DEY
	BNE GETKJ33
; up means parent directory, send "ESC"
	LDA #28
	JMP DOGETK
GETKJ33
; adjust driveno: down = same, left = -1 , right = +1
	TAX
	CLC
	LDA DRIVENO
	ADC DRVADJ,Y
	AND #7
	TAX
	LDA DRVKEY,X
	JMP DOGETK

; drive number adjust for up/down/left/right
DRVADJ .BYTE 0, 0, $FF,1

; keys to send for drive number 8, 1-7
DRVKEY	.BYTE 53, 31, 30, 26, 24, 29, 27, 51

GETKJS4
; invalid state, switch to wait idle
	LDA #JOYSTATE_WAIT_IDLE
	STA JOYSTAT
	JMP GETKEY

OLD20	.BYTE 0
OLDJOY	.BYTE 0
WTJOY	.BYTE 0
JOYSTAT	.BYTE 0

PRTFOR	LDA #0
	STA PRTFSEL
	LDA SECMASK
	CMP #$FF
	BNE PNOMY
	LDA PRTFSEL
	ORA #2
	STA PRTFSEL
PNOMY	LDA SECBYTE
	CMP #253
	BNE PNODD
	INC PRTFSEL
PNODD	LDA DSKFOR
	BNE PFNAUTO

	LDA PRTFSEL
	AND #$01
	ORA #$04
	STA PRTFSEL
PFNAUTO	LDA PRTFSEL
	ASL
	TAX
	LDA PFTAB,X
	STA PRTFLP+1
	LDA PFTAB+1,X
	STA PRTFLP+2
	
	LDX #FORLEN-1
PRTFLP	LDA $1234,X
	STA DFORMAT,X
	DEX
	BPL PRTFLP
	RTS

CLRMEM2	LDA #0
	TAY
MEMCLR	STA (0),Y
	DEY
	BNE MEMCLR
	INC 1
	LDX 1
	CPX #>CLREND
	BNE MEMCLR
	RTS

CLRLEN	= *-CLRMEM2

GR0	CLOSE 0
	OPEN 0,12,0,EDITOR
	LDA 20
	CLC
	ADC #2
WVBI	CMP 20
	BNE WVBI
	RTS

EDITOR	.BYTE "E:", 155

BASON	LDA $D20F
	AND #8
	BEQ EBASON

	LDA #0
	STA $BFFD
	LDA $BFFD
	BNE EBASON

	LDA #$A0
	STA 106
	STA 740
	JSR GR0
	LDA #0
	STA 1016

	LDA $D301
	AND #$FD
	STA $D301

EBASON	RTS

CHKBAS	LDA #0
	STA $BFFD
	LDA $BFFD
	BEQ NOBAS
	RTS
NOBAS	BPUT 0, NOBASL, NOBAST
	JMP *

NOBAST	.BYTE 125, "No BASIC found!",253,155
NOBASL	= * - NOBAST

BASOFF	LDA $D20F
	AND #8
	BEQ EBASOFF
	LDA #0
	STA $BFFD
	LDA $BFFD
	BEQ EBASOFF
	LDA $D301
	ORA #2
	STA $D301
	LDA #0
	STA $BFFD
	LDA $BFFD
	BNE EBASOFF

; clear display list / screen and RAM under basic ROM

	LDA #$9C
	STA TEMPV+1
	LDA #0
	STA TEMPV
	TAY
	LDX #$24
CLLP	STA (TEMPV),Y
	INY
	BNE CLLP
	INC TEMPV+1
	DEX
	BNE CLLP

	LDA #$C0
	STA 106
	STA 740
	LDA #1
	STA 1016
	JSR GR0
EBASOFF	RTS

	.IF .DEF HIGHSPEED

CHKHI	LDA NE459+2
	CMP #$E4
	BNE CHSPDHI

SPDLO	LDA #$E4
	STA NE459+2
	LDA #$59
	STA NE459+1
	CLC
	RTS

CHSPDHI	LDX DRIVENO
	LDA SPEEDTB-1,X
	BEQ SPDLO
	CMP #$29	; new highspeed code adds 1 to entries in table
	BEQ SPDLO
	SEC
	SBC #1
	STA SIOSPEED
	LDX #<SIOEND
	LDY #>SIOEND

; use highspeed code without speed detection for loading to save
; a few bytes of memory
	LDA #<SIOADR
	STA NE459+1
	LDA #>SIOADR
	STA NE459+2
	SEC
	RTS

SPDHI	LDA #<HISIO
	STA NE459+1
	LDA #>HISIO
	STA NE459+2
	SEC
	RTS

	.ENDIF

LOAD	LDX #CLRLEN-1
CCL	LDA CLRMEM2,X
	STA CLRMEM,X
	DEX
	BPL CCL

	LDA #<ENDX
	STA 738
	LDA #>ENDX
	STA 739

	LDX #<BUF
	STX DBUF
	STX BYTES
	LDA #>BUF
	STA DBUF+1

	JSR GETBYT
	STA TEMPV
	JSR GETBYT
	STX XREG
	STA TEMPV+1
	AND TEMPV
	CMP #255
	BNE LOAD2

	JSR BASOFF
	COP768 COMLD, COMLOAD, COMLEN

	; update init address
	LDA #<ENDX
	STA 12
	LDA #>ENDX
	STA 13

	.IF .DEF HIGHSPEED
	JSR CHKHI
	BCS LDCOM2
	.ELSE
	.IF .DEF CARTSIO
	LDX #<SIOEND
	LDY #>SIOEND
	BNE LDCOM2
	.ENDIF
	.ENDIF

COMSIO1	LDX #<COMLEND
	LDY #>COMLEND

LDCOM2	STX 0
	STY 1
	LDA #0
	STA 580
	LDX XREG
	JMP COMLD

LOAD2	LDA TEMPV
	ORA TEMPV+1
	BNE BINOK

	JMP LOADBAS

BINOK	
.if .def THECART
	LDA TEMPV
	CMP #'C
	BNE BINOK1
	LDA TEMPV+1
	CMP #'A
	BNE BINOK1
	JMP LOADCAR
BINOK1
.endif
	JSR BASOFF
	LDX XREG
	JSR GETBYT
	STA DBUF	; start adr. LO
	JSR GETBYT
	STA DBUF+1	; start adr. HI
	CLC
	LDA DBUF	; start adr + 6 = init adress
	ADC #6
	STA BLEN
	LDA DBUF+1
	ADC #0
	STA BLEN+1

	JSR GETBYT
	STA 12	; Run-Adr. LO
	JSR GETBYT
	STA 13	; Run-Adr. HI

	LDA SECMASK
	STA BINMASK+1
	LDA SECBYTE
	STA BINBYTE+1

	.IF .DEF HIGHSPEED
	JSR CHKHI

	LDA NE459+1
	STA BINSIO+1
	LDA NE459+2
	STA BINSIO+2
	BCS CPBIN1
	.ELSE
	.IF .DEF CARTSIO
	LDA #<SIOADR
	STA BINSIO+1
	LDA #>SIOADR
	STA BINSIO+2
	LDX #<SIOEND
	LDY #>SIOEND
	BNE CPBIN1
	.ENDIF
	.ENDIF

BINSIO1	LDX #<LDBINLO
	LDY #>LDBINLO

; kopiere Laderoutine nach $80

CPBIN1	STX 0
	STY 1
	LDX #BINLEN
L2CLOP	LDA BINLOAD,X
	STA LDBINAD,X
	DEX
	BPL L2CLOP
	JMP LDBINAD

; das hier ist die Laderoutine:

BINLOAD	JSR CLRMEM
BINLOOP	LDA #$40
	STA $303
BINSIO	JSR $E459
	BMI BINLOOP

	LDA DBUF
	STA ADR
	LDA DBUF+1
	STA ADR+1

BINBYTE	LDY #253
	LDA (ADR),Y ; naechster
BINMASK	AND #$FF
	STA DSEC+1

	INY
	LDA (ADR),Y
	STA DSEC
	ORA DSEC+1
	BEQ BINEND

	INY
	CLC
	LDA DBUF
	ADC (ADR),Y
	STA DBUF
	BCC BINLOOP
	INC DBUF+1
	BNE BINLOOP

BINEND	; JSR JJ1
	.BYTE $20
	.WORD JJ1
	; JSR JJ2
	.BYTE $20
	.WORD JJ2
	JMP (10)

JJ1	= *-BINLOAD+LDBINAD
	JMP (BLEN)
JJ2	= *-BINLOAD+LDBINAD
	JMP (12)

BINLEN	= * - BINLOAD

LOADBAS	JSR BASON
	JSR CHKBAS
	COP768 BASLD, BASLOAD, BASLEN

	.IF .DEF HIGHSPEED
	JSR CHKHI
	BCS LDBAS2
	.ELSE
	.IF .DEF CARTSIO
	LDA #<SIOADR
	STA BINSIO+1
	LDA #>SIOADR
	STA BINSIO+2
	LDX #<SIOEND
	LDY #>SIOEND
	BNE LDBAS2
	.ENDIF
	.ENDIF

BASSIO1	LDX #<BASLEND
	LDY #>BASLEND

LDBAS2	STX 0
	STX $80
	STY 1
	STY $81

	LDA #0
	STA 580

; set tab width to 10 - otherwise some basic
; programs will just crash!

	LDA #10
	STA $C9

	LDA #<ENDX
	STA 738
	LDA #>ENDX
	STA 739

	LDX XREG

STORLP	JSR GETBYT
	STA ADR
	JSR GETBYT
	STA ADR+1
	CLC
	LDA ADR
	ADC $80
STORL	STA $82
	LDA ADR+1
	ADC $81
STORH	STA $83
	INC STORL+1
	INC STORL+1
	INC STORH+1
	INC STORH+1
	LDA STORL+1
	CMP #$8E
	BNE STORLP

	LDA $8C
	STA $8E
	STA $90
	STA $0E

	LDA $8D
	STA $8F
	STA $91
	STA $0F

	JMP BASLD

SETFMT	DEX
	BMI SETFAUT
	LDA DBYTTAB,X
	STA SECBYTE
	LDA DMSKTAB,X
	STA SECMASK
	LDA DLENLO,X
	STA $308
	LDA DLENHI,X
	STA $309
	RTS

SETFAUT	LDA DSKBYT
	STA SECBYTE
	LDA DSKLEN
	STA $308
	LDA DSKLEN+1
	STA $309
	RTS

; convert atascii to screen code

INTERNAL	CMP #32
	BCC INTGRAF
	CMP #96
	BCC INTNORM
	CMP #128
	BCC INTNO
	CMP #160
	BCC INTGRAF
	CMP #224
	BCS INTNO

INTNORM	SEC
	SBC #32
	JMP INTNO

INTGRAF	CLC
	ADC #64
INTNO	RTS

DBYTTAB	.BYTE 125,125,253,253
DMSKTAB	.BYTE $03,$FF,$03,$FF
DLENLO	.BYTE 128,128,0,0
DLENHI	.BYTE 0,0,1,1

PICOSYS	.BYTE "PICODOS SYS"
PICONAM .BYTE "PICONAMETXT"

; use long names
USELONG	.BYTE 1

; disk fromat (0 = auto)
DSKFOR	.BYTE 0

DSKERR	.SBYTE "Disk Error!"
DERRLEN	= *-DSKERR

DSKEMPT	.SBYTE "Empty Dir! "
DEMPTLEN	= *-DSKEMPT

	SIOVEC = NE459
	.include "getdens.src"

	.IF .DEF REMOTE
	BUFFER = SCREEN
	.include "remote.src"
	.ENDIF

	.IF .DEF CARTSIO
	.include "imginfo.src"
	.ENDIF

	.if .def THECART
	.include "carloadcode.src"
	.endif

	.if .def HWDEBUG
	.include "hwdebsup.src"
	.endif

PFTAB	.WORD FORSD, FORDD, FORSM, FORDM
	.WORD FORASD, FORADD

XTAB	.BYTE 1,14,27

	.IF .DEF MYPDOSBIN

	.IF (*&127)<>0
	.DC (128-(*&127)) 0
	.ENDIF

	.ENDIF

PICOEND	= *

; misc storage setup

	* = STORAGE

; drive number display
DRVLIN	* = * + 40
DSKOFS	= DRVLIN+17

; upper horizontal separator line / directory title
TLINE1	* = * + 40
; lower horizontal separator line / directory title
TLINE2	* = * + 40
; position of up/down arrows
INDUP	= TLINE1+39
INDDWN	= TLINE2+39

FILES	* = * + 1
MAXY	* = * + 1
MAXX	* = * + 1
XPOS	* = * + 1
YPOS	* = * + 1
AUTORUN	* = * + 1

SCRY	* = * + 1
REMAIN	* = * + 1
MAXFILE * = * + 1

; current drive number
DRIVENO	* = * + 1

; current start of directory
DIRSEC	* = * + 2

; remember old display list
OLD560	* = * + 2

; remember old background color
OLD710	* = * + 1

; autodetected disk format
DSKBYT	* = * + 1
DSKLEN	* = * + 2

PRTFSEL	* = * + 1

; number of files in directory
DIRFILES * = * + 1
; temporary counter used by FINDFIL
DIRCNT	* = * + 1
; sector start of PICONAME.TXT
NAMESEC	* = * + 2

; got long names
LONGFLG	* = * + 1

; temporary screen address
SADR1	* = * + 2

; end of long name buffer
NAMEEND	* = * + 2

; rightmost character in upper horizontal bar
TLUP	* = * + 1

; filename from PICONAME.TXT
FILNAM	* = * + 11
; long name from PICONAME.TXT in screen code
LONGNAM	* = * + 40

STOREND	= *
